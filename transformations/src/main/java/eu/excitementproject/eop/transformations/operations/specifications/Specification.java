package eu.excitementproject.eop.transformations.operations.specifications;
import java.io.Serializable;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;

import eu.excitementproject.eop.transformations.operations.operations.GenerationOperation;
import eu.excitementproject.eop.transformations.representation.ExtendedNode;
//import eu.excitementproject.eop.transformations.rteflow.macro.TreeHistory;


/**
 * A Specification contains information about an operation to be done on a tree.
 * Usually, a {@link GenerationOperation} takes a {@link Specification} as one of its
 * arguments, and makes the operation according to the information specified by
 * the {@link Specification}.
 * <P>
 * <B>Specification is not thread safe!</B>
 * Do not use the same {@linkplain Specification} in two threads.
 * <P>
 * Note that specification is <B>not</B> immutable!
 * <P>
 * The specification can be used later not only for the generation-operation, but also
 * to describe the proof for a human reader. Each Specification has the method {@link #toString()},
 * that returns a human-readable description of a proof step. A {@link TreeHistory} stores a vector
 * of specifications for that purpose.
 * 
 *  
 * @author Asher Stern
 * @since Jan 11, 2011
 *
 */
public abstract class Specification implements Serializable
{
	private static final long serialVersionUID = -4389371657334158353L;
	
	
	/**
	 * The tree - is the tree on which the operation is going to be performed.
	 * The nodes - nodes in this tree that are involved in that operations.
	 * Nodes are "involved" if the operation can be performed only due to their
	 * existence in the tree.
	 * <BR>
	 * <B>More concretely:</B> If the given tree (t) is a result of a previous operation
	 * performed on an earlier tree (t')
	 * (i.e. t was generated by applying an operation o on t'), and if this specification
	 * specifies an operation (o') that can be performed on t but not on t' - then the
	 * all of the "involved nodes" exist in t but not in t' (though some of them may exist
	 * in t', but not all).
	 * <P>
	 * <B>Examples:</B> In substitution node specification - than the involved nodes is only
	 * the node to be substituted.<BR>
	 * In Rule specification - the involved nodes are those nodes that are mapped to the
	 * left-hand-side of the rule.<BR>
	 * In Insert node specification - the involved nodes are the node to be the parent of the
	 * inserted node.<BR>
	 * In move subtree specification - the involved nodes are the node to be moved and the node
	 * that will be the new parent of the moved node.<BR>
	 * 
	 * @return The set of "involved nodes".
	 */
	public abstract Set<ExtendedNode> getInvolvedNodesInTree();

	/**
	 * Subclasses should implement this method such that it will return a human-readable
	 * description of the proof-step.
	 */
	public String toString()
	{
		StringBuffer sb = specString();
		if (this.additionalDescriptionsAsString()!=null){if(this.additionalDescriptionsAsString().length()>0)
		{
			sb.append("(");
			sb.append(this.additionalDescriptionsAsString());
			sb.append(") ");
		}}
		return sb.toString();
	}
	
	public abstract StringBuffer specString();
	
	/**
	 * @return a SHORT user friendly description of the spec
	 */
	public abstract String toShortString();
	
	
	/**
	 * Adds some description about the proof-step.
	 * Sub-classes can decide whether to use that additional information when they
	 * return a description of the specification in the {@link #toString()} method.
	 * 
	 * @param additionalDescription A human readable additional information about the specification.
	 */
	public void addDescription(String additionalDescription)
	{
		if (additionalDescriptions==null)
			additionalDescriptions = new LinkedList<String>();
		
		additionalDescriptions.add(additionalDescription);
	}
	
	/**
	 * Creates a comma-separated string composed of all additional descriptions that were added by the
	 * {@link #addDescription(String)} method.
	 * @return
	 */
	public String additionalDescriptionsAsString()
	{
		if (this.additionalDescriptions!=null)
		{
			StringBuffer ret = new StringBuffer();
			boolean firstIteration = true;
			for (String description : this.additionalDescriptions)
			{
				if (firstIteration)firstIteration=false;
				else
					ret.append(", ");
				
				ret.append(description);
			}
			return ret.toString();
		}
		else
		{
			return "";
		}
		
	}
	
	protected List<String> additionalDescriptions = null;
}
