package eu.excitementproject.eop.biutee.operations.updater;
import java.util.Map;

import eu.excitementproject.eop.biutee.rteflow.macro.FeatureUpdate;
import eu.excitementproject.eop.common.representation.parse.tree.TreeAndParentMap;
import eu.excitementproject.eop.transformations.operations.operations.GenerationOperation;
import eu.excitementproject.eop.transformations.operations.specifications.Specification;
import eu.excitementproject.eop.transformations.representation.ExtendedInfo;
import eu.excitementproject.eop.transformations.representation.ExtendedNode;
import eu.excitementproject.eop.transformations.utilities.TeEngineMlException;



/**
 * A class that gets a newly created tree, and a feature vector that was created earlier
 * for the older tree from which the newly created tree was created - and creates
 * a new feature-vector for the newly created tree. 
 * 
 * @author Asher Stern
 * @since January 2012
 *
 * @param <T>
 */
public abstract class FeatureVectorUpdater<T extends Specification>
{
	/**
	 * Creates a new feature-vector for the new tree that has been generated by
	 * the operation.
	 * <BR>
	 * <B>Note - whatever you do - the features can get only negative values,
	 * and their values should only decrease!</B>. For example, if a value of some
	 * feature was -3.0, then a new value of -4.0 is legal, but not a new value of -2.0.
	 * 
	 * @param originalFeatureVector
	 * @param featureUpdate
	 * @param textTree
	 * @param hypothesisTree
	 * @param operation
	 * @param specification
	 * @return
	 * @throws TeEngineMlException
	 */
	public abstract Map<Integer,Double> updateFeatureVector(Map<Integer,Double> originalFeatureVector,
			FeatureUpdate featureUpdate,
			TreeAndParentMap<ExtendedInfo, ExtendedNode> textTree,
			TreeAndParentMap<ExtendedInfo, ExtendedNode> hypothesisTree,
			GenerationOperation<ExtendedInfo, ExtendedNode> operation,
			T specification) throws TeEngineMlException;

}
